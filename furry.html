<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
		background: black;
	}
	div {
		-webkit-border-radius: 4px;
	}
	.c0 {
		background-color: black;
	}
/* non-player blocks, inactive player block, active player block */
	.c1 {
		background-color: #933;
	}
	.c2 {
		background-color: #993;
	}
	.c3 {
		background-color: #339;
	}
/* inactive player block, active player block */
	.c4, .c7 {
		background-color: #c66;
	}
	.c5, .c8 {
		background-color: #cc6;
	}
	.c6, .c9 {
		background-color: #66c;
	}
</style>
<div id="board"></div>
<script>
var BOARD_WIDTH = 8,
	BOARD_HEIGHT = 17, // allow an extra top row for rotation
	NUM_COLORS = 3,
	NUM_TO_MATCH = 4, // pieces in a row required for "match"
	DROP_INTERVAL = 900, // ms it takes an active piece to move down one space
	DROP_INTERVAL_CASCADE = 900, // ms it takes a "cascading" piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing
	NEW_PIECE = [// new pieces start middle of second row from top
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2) - 1,
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2)
	],
	look = {
		left: function (n) { return (n % BOARD_WIDTH) ? (n - 1) : -1; },
		right: function (n) { return (BOARD_WIDTH - (n % BOARD_WIDTH) - 1) ? (n + 1) : -1; },
		down: function (n) { return Math.floor(n / BOARD_WIDTH) ? (n - BOARD_WIDTH) : -1; },
		up: function (n) { return (BOARD_HEIGHT - Math.floor(n / BOARD_WIDTH) - 1) ? (n + BOARD_WIDTH) : -1; }
	},
	direction_opposites = {
		left: "right",
		right: "left",
		down: "up",
		up: "down"
	},
	rotate_map = [ // this is how to rotate this piece in the possible orientations
		[
			function (n) { return n; },
			function (n) { return look.up(look.left(n)); }
		], [
			function (n) { return look.right(n); },
			function (n) { return look.down(n); }
		], [
			function (n) { return look.up(look.left(n)); },
			function (n) { return n; }
		], [
			function (n) { return look.down(n); },
			function (n) { return look.right(n); }
		]
	],
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			board_dom.style.width = board_w + "px";
			board_dom.style.height = board_h + "px";

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.position = "absolute";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					e.innerHTML = (i * BOARD_WIDTH) + j;
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + board[i];
			}
		}

	},
	board,
	piece, // controllable piece
	npps = [], // "non-player pieces"
	next_npps = []
;

function match(n, direction) {
	var l;

	if (board[n] === 0) {
		return [];
	}

	l = look[direction](n);
	if (
		l === -1
		|| (board[n] % NUM_COLORS) !== (board[l] % NUM_COLORS)
	) {
		return [n];
	}

	// l matches so keep looking that way
	return [n].concat(match(l, direction));
}

function cascade(n) {
	function canCascade(n) {
		// only player-placed blocks can cascade
		return (board[n] > NUM_COLORS) && (board[n] <= (NUM_COLORS * 2));
	}

	if (!canCascade(n)) {
		console.log(n + " : " + board[n]);
		return [];
	}

	console.log(n + " can cascade!");

	return [n].concat(cascade(look.up(n)));
}

function newBoard() {
	var START_HEIGHT = 8, // max height to place starting yin pieces
		START_DENSITY = 0.8, // density of pieces on starting board, between 0 (nothing) and 1 (completely full)
		START_MAX_IN_A_ROW = 2; // don't allow more than this many pieces of the same color anywhere to start
	;

	// Create an empty board
	function empty() {
		var i, a = [];
		for (i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
			a.push(0);
		}
		return a;
	}

	// Populate spots on the board
	function fill(n, board, allow_empty) {
		board[n] = 0;
		if (allow_empty && Math.random() <= START_DENSITY) {
			board[n] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		}

		return (n == (START_HEIGHT * BOARD_WIDTH) - 1)
		? board
		: ((match(n, 'left').length <= START_MAX_IN_A_ROW && match(n, 'down').length <= START_MAX_IN_A_ROW)
			? fill(++n, board, true)
			: fill(n, board, false)
		);
	}

	return fill(0, empty(), true);
}

function checkMove(direction) {
	var l;
	for (i = 0; i < this.blocks.length; i++) {
		l = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);

		if (
			0 !== board[l]
			&& this.blocks.indexOf(l) === -1
		) {
			return false;
		}
	}
	return true;
}

function move(direction) {
	var i, c;
	c = [];
	for (i = 0; i < this.blocks.length; i++) {
		c[i] = board[this.blocks[i]];
		board[this.blocks[i]] = 0;
		this.blocks[i] = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);
	}
	for (i = 0; i < c.length; i++) {
		board[this.blocks[i]] = c[i];
	}
	if (direction ==="rotate") {
		this.orientation = (1 + this.orientation) % 4;
	}
}

function newPiece(now) {
	var i, blocks = [];
	for (i = 0; i < NEW_PIECE.length; i++) {
		if (board[NEW_PIECE[i]] !== 0) {
			// GAME OVER
			return;
		}
		board[NEW_PIECE[i]] = Math.floor(Math.random() * (NUM_COLORS) + (NUM_COLORS * 2) + 1);
		blocks.push(NEW_PIECE[i]);
	}

	return {
		blocks: blocks,
		orientation: 0,
		pending_drop: now + DROP_INTERVAL,
		pending_settle: 0,
		pending_moves: [],
		move: move,
		checkMove: checkMove,
	};
}

function newNpp(n) {
	return {
		blocks: [n],
		pending_drop: 0,
		move: move,
		checkMove: checkMove
	};
}

function nppSort(npp1, npp2) {
	return npp1.blocks[0] - npp2.blocks[0]; 
}

function nppsUnique(npps) {
	var i, c = {}, n = [];
	for (i = 0; i < npps.length; i++) {
		if (!c.hasOwnProperty(npps[i].blocks[0])) {
			c[npps[i].blocks[0]] = true;
			n.push(npps[i]);
		}
	}
	return n;
}

function loop() {
	var now = new Date * 1,
		i, j,
		m,
		check_match = [],
		matches = []
	;

	if (npps.length > 0) {

		// we must move the lowest npps first
		npps = nppsUnique(npps);
		npps.sort(nppSort);

		next_npps = [];
		for (i = 0; i < npps.length; i++) {
			if (npps[i].pending_drop <= now) {
				npps[i].move("down");
				if (npps[i].checkMove("down")) {
					npps[i].pending_drop = now + DROP_INTERVAL_CASCADE;
					next_npps.push(npps[i]);
				} else {
					console.log("ndm for " + npps[i].blocks[0]);
					console.log(board[look.down(npps[i].blocks[0])]);
					//todo: check for matches!
				}
			} else {
				next_npps.push(npps[i]);
			}
		}
		npps = next_npps;
		return next(DROP_INTERVAL_CASCADE);
	}

	if (!piece) {
		piece = newPiece(now);
		if (!piece) {
			// GAME OVER
			return;
		}
	}

	if (piece.pending_settle) {
		if (piece.pending_settle <= now) {
			// convert piece blocks to inactive
			for (i = 0; i < piece.blocks.length; i++) {
				board[piece.blocks[i]] -= NUM_COLORS;
			}

			for (i = 0; i < piece.blocks.length; i++) {
				for (j in look) {
					if (look.hasOwnProperty(j)) {
						check_match = match(piece.blocks[i], j)
							// a match must include the opposite direction
							.concat(match(piece.blocks[i], direction_opposites[j]));
						// - 1 because the current block is included twice
						if (check_match.length - 1 >= NUM_TO_MATCH) {
							matches = matches.concat(check_match);
						}
					}
				}
				if (matches.length > 0) {
					for (j = 0; j < matches.length; j++) {
						board[matches[j]] = 0;
					}
				}
			}

			piece = false;

			if (matches.length > 0) for (i = 0; i < matches.length; i++) {
				// just throwing the numbers on the array;
				// we'll convert them to npp objects as needed
				cascade(look.up(matches[i])).forEach(function (npp) {
					var new_npp = newNpp(npp);
					new_npp.pending_drop = now + DROP_INTERVAL;
					npps = npps.concat(new_npp);
				});
				["left", "right"].forEach (function (dir) {
					var l = look[dir](matches[i]),
						new_npp = (l > 0) ? newNpp(l) : false;
					if (new_npp && new_npp.checkMove("down")) {
						cascade(
							new_npp.blocks[0]
						).forEach(function (npp) {
							var new_npp = newNpp(npp);
							new_npp.pending_drop = now + DROP_INTERVAL_CASCADE;
							npps = npps.concat(new_npp);
						});
					}
				});
			}

			return next();
		}
	} else if (!piece.checkMove("down")) {
		piece.pending_settle = now + SETTLE_INTERVAL;
		piece.pending_drop = 0;
	} else if (piece.pending_drop && piece.pending_drop <= now) {
		piece.move('down');
		piece.pending_drop = now + DROP_INTERVAL;
	}

	m = piece.pending_moves.pop();
	if (m && piece.checkMove(m)) {
		piece.move(m);
		if (m === "down" && piece.checkMove("down")) {
			piece.pending_drop = now + DROP_INTERVAL;
		} else {
			if (piece.pending_settle && piece.checkMove("down")) {
				// Unset the settle timer and re-set drop timer if the move has
				// resulted in more possible down moves.
				piece.pending_settle = 0;
				piece.pending_drop = now + DROP_INTERVAL;
			}
		}
	}

	next();
}

function next(interval) {
	renderer.render(board);
	setTimeout(
		function () {
			loop();
		},
		(arguments.length > 1) ? interval : 20
	);
}

renderer.init();

board = newBoard(BOARD_WIDTH, BOARD_HEIGHT);
loop();

onkeydown = function (e) {
	var d;
	switch (e.keyCode) {
		case 37: // left arrow
		case 65: // "a"
			piece && piece.pending_moves.unshift("left");
			return false;
		case 39: // right arrow
		case 68: // "d"
			piece && piece.pending_moves.unshift("right");
			return false;
		case 40: // down arrow
		case 83: // "s"
			piece && piece.pending_moves.unshift("down");
			return false;
		case 38: // up arrow
		case 87: // "w"
			// todo: instaplace
			return false;
		case 32: // space
		case 17: // ctrl
		case 13: // enter
		case 16: // shift
			piece && piece.pending_moves.unshift("rotate");
			return false;
		case 27: // ESC
			// debug -- STOP!!
			next = null;
			return false;
		default:
			return true;
	}
};
</script>
