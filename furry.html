<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
		background: black;
	}
	#board div {
		position: absolute;
		text-align: center;
	}
	.c0 {
		background-color: black;
	}
/* enemy blocks */
	.c1 {
		background-color: #933;
	}
	.c2 {
		background-color: #993;
	}
	.c3 {
		background-color: #339;
	}
/* player blocks */
	.c4 {
		background-color: #c66;
		border-radius: 50%;
	}
	.c5 {
		background-color: #cc6;
		border-radius: 50%;
	}
	.c6 {
		background-color: #66c;
		border-radius: 50%;
	}
/* connected at top */
	.b1 {
		border-radius: 0;
		border-bottom-left-radius: 50%;
		border-bottom-right-radius: 50%;
	}
/* connected at right */
	.b2 {
		border-radius: 0;
		border-top-left-radius: 50%;
		border-bottom-left-radius: 50%;
	}
/* connected at bottom */
	.b4 {
		border-radius: 0;
		border-top-left-radius: 50%;
		border-top-right-radius: 50%;
	}
/* connected at left */
	.b8 {
		border-radius: 0;
		border-top-right-radius: 50%;
		border-bottom-right-radius: 50%;
	}

/* matches */
	.c7 {
		background-color: black;
	}
	.c7:after {
		content: "";
		position: absolute;
		top: 0;
		right: 0;
		bottom: 0;
		left: 0;
		border: 1px solid #aaa;
		border-radius: 50%;
	}

</style>
<div id="board"></div>
<script>
var
	// Basic game parameters
	BOARD_WIDTH = 8,
	BOARD_HEIGHT = 17, // allow an extra top row for rotation
	NUM_COLORS = 3,
	NUM_TO_MATCH = 4, // pieces in a row required for match
	DROP_INTERVAL = 600, // ms it takes an active piece to move down one space
	DROP_INTERVAL_CASCADE = 600, // ms it takes a "cascading" piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing
	MATCH_PAUSE = 600, // ms to pause when highlighting match
	DEFAULT_LOOP_DELAY = 20,

	// Game start parameters

	START_HEIGHT = 8,
	// Probabilistic density of pieces on starting board, between 0 (nothing)
	// and 1 (completely full)
	START_DENSITY = 0.8,
	// Max consecutive instances of any one color to start
	START_MAX_IN_A_ROW = 2,

	// Bits that indicate connections
	CONNECT_TOP = 0x0100,
	CONNECT_RIGHT = 0x0200,
	CONNECT_BOTTOM = 0x0400,
	CONNECT_LEFT = 0x0800,
	CONNECTIONS = CONNECT_TOP | CONNECT_RIGHT | CONNECT_BOTTOM | CONNECT_LEFT,

	MATCH_PENDING = NUM_COLORS * 2 + 1,

	// New piece template
	NEW_PIECE = [
		// [ position, connect state[, ...] ]
		// (random color is added at generation)
		// These positions represent the middle of the second row from top.
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2) - 1,
		CONNECT_RIGHT,
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2),
		CONNECT_LEFT
	],
	// create a function that accepts values or arrays
	mappable = function (fn) {
		return function (arg) {
			return Array.isArray(arg) ? arg.map(fn) : fn(arg);
		}
	},
	id = function (x) {
		return x;
	},
	// How to traverse the board
	go = {
		up: mappable(function (p) {
			return (BOARD_HEIGHT - Math.floor(p / BOARD_WIDTH) - 1)
			? (p + BOARD_WIDTH)
			: -1;
		}),
		right: mappable(function (p) {
			return (BOARD_WIDTH - (p % BOARD_WIDTH) - 1)
			? (p + 1)
			: -1;
		}),
		down: mappable(function (p) {
			return Math.floor(p / BOARD_WIDTH)
			? (p - BOARD_WIDTH)
			: -1;
		}),
		left: mappable(function (p) {
			return (p % BOARD_WIDTH)
			? (p - 1)
			: -1;
		}),
		rotate_left: [
			function (ps) {
				return [
					ps[0],
					go.up(go.left(ps[1]))
				];
			},
			function (ps) {
				return [
					go.right(ps[0]),
					go.down(ps[1])
				];
			},
			function (ps) {
				return [
					go.up(go.left(ps[0])),
					ps[1]
				];
			},
			function (ps) {
				return [
					go.down(ps[0]),
					go.right(ps[1])
				];
			}
		],
		rotate_right: [
			function (ps) {
				return [
					go.up(go.right(ps[0])),
					ps[1]
				];
			},
			function (ps) {
				return [
					go.down(ps[0]),
					go.left(ps[1])
				];
			},
			function (ps) {
				return [
					ps[0],
					go.up(go.right(ps[1]))
				];
			},
			function (ps) {
				return [
					go.left(ps[0]),
					go.down(ps[1])
				];
			}
		]
	},
	// Direction constants
	up = "up",
	right = "right",
	down = "down",
	left = "left",
	rotate_left = "rotate_left",
	rotate_right = "rotate_right",

	// Turn an array [key, value[,...]] into a hash
	// Sugar for declaring objects with expressions as keys
	makeHash = function(array) {
		var i, hash = {};
		for (i = 0; i < array.length; i += 2) {
			hash[array[i]] = array[i + 1];
		}
		return hash;
	},
	go_connect = makeHash([
		CONNECT_TOP, go.up,
		CONNECT_RIGHT, go.right,
		CONNECT_BOTTOM, go.down,
		CONNECT_LEFT, go.left
	]),
	opposite_connection = makeHash([
		CONNECT_TOP, CONNECT_BOTTOM,
		CONNECT_RIGHT, CONNECT_LEFT,
		CONNECT_BOTTOM, CONNECT_TOP,
		CONNECT_LEFT, CONNECT_RIGHT
	]),

	// How to maintain connections when rotating
	rotation_state = {
		up: mappable(id),
		right: mappable(id),
		down: mappable(id),
		left: mappable(id),
		rotate_left: [
				function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_TOP; },
				function (s) { return (s ^ CONNECT_LEFT) | CONNECT_BOTTOM; }
			], [
				function (s) { return (s ^ CONNECT_TOP) | CONNECT_LEFT; },
				function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_RIGHT; }
			], [
				function (s) { return (s ^ CONNECT_LEFT) | CONNECT_BOTTOM; },
				function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_TOP; }
			], [
				function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_RIGHT; },
				function (s) { return (s ^ CONNECT_TOP) | CONNECT_LEFT; }
			]
		],
		rotate_right: [
				function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_BOTTOM; },
				function (s) { return (s ^ CONNECT_LEFT) | CONNECT_TOP; }
			], [
				function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_LEFT; },
				function (s) { return (s ^ CONNECT_TOP) | CONNECT_RIGHT; }
			], [
				function (s) { return (s ^ CONNECT_LEFT) | CONNECT_TOP; },
				function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_BOTTOM; }
			], [
				function (s) { return (s ^ CONNECT_TOP) | CONNECT_RIGHT; },
				function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_LEFT; }
			]
		]
	},
	rotation_orient = {
		rotate_left: function (o) {
			return (o + 1) % 4;
		},
		rotate_right: function (o) {
			return (o + 3) % 4;
		}
	}
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			board_dom.style.width = board_w + "px";
			board_dom.style.height = board_h + "px";

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					e.innerHTML = (i * BOARD_WIDTH) + j;
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + (board[i] % 256) + " b" + (board[i] >> 8);
			}
		}
	},

	// A list of integers representing the state of every spot on the board,
	// starting from the lower left. Possible states, where n = NUM_COLORS:
	// -1 invalid (not on board)
	//  0 empty
	//  1 - n "enemy" blocks placed at start
	//  n+1 - 2n player blocks
	// 2n+1 matched blocks
	//  ... Player block states can have the bits 2^8-11 flipped on to
	// indicate bindings to the top, right, bottom and left, respectively.
	// Note that since connections bits start at 256, max NUM_COLORS is 127.
	board = [],

	// The controllable piece, if one exists
	piece
;

function colorOf(p) {
	return (board[p] & ~CONNECTIONS) % NUM_COLORS;
}

function match(direction, p) {
	if (board[p] === 0) {
		return [];
	}

	var g = go[direction](p);

	if (g === -1 || colorOf(p) !== colorOf(g)) {
		return [p];
	}

	// g matches so keep looking that way
	return [p].concat(match(direction, g));
}

function matchScan() {
	var p,
		check_match,
		matches = []
	;
	for (p = 0; p < board.length; p++) {
		[up, right].forEach(function (dir) {
			check_match = match(dir, p);
			if (check_match.length >= NUM_TO_MATCH) {
				matches = matches.concat(check_match);
			}
		});
	}
	return matches;
}

function isPlayerBlock(p) {
	return board[p] > NUM_COLORS;
}

function canCascade(p, npps, from_conn) {
	from_conn = from_conn || 0;

	var below = go.down(p),
		below_is_empty = board[below] === 0,
		below_is_attached = from_conn === CONNECT_BOTTOM,
		further_connections = (board[p] & (CONNECTIONS ^ from_conn)),
		conn_check,
		conn_cascades = [],
		i
	;

	if (board[p] <= NUM_COLORS) {
		// Only player blocks can cascade.
		return [];
	}

	if (!below_is_empty && !below_is_attached && nppsSearch(below, npps) === -1) {
		// Block below is neither empty, attached to me nor cascading
		return [];
	}

	if (further_connections === 0) {
		return [p];
	}

	// loop over all possible connections
	for (i = CONNECT_TOP; i & CONNECTIONS; i = i << 1) {
		if (i & from_conn || !(board[p] & i)) {
			// we came from this direction, or not connected
			continue;
		}
		conn_check = canCascade(go_connect[i](p), npps, opposite_connection[i]);
		if (conn_check.length === 0) {
			// All connected blocks must be cascadable
			return [];
		} else {
			conn_cascades = conn_cascades.concat(conn_check);
		}
	}
	return conn_cascades.concat(p);
}

function cascadeScan() {
	var i, j,
		npps = [],
		cascade_check,
		already_cascading = {}
	;
	// We can skip the first row for obvious reasons
	for (i = BOARD_WIDTH; i < board.length; i++) {
		if (already_cascading.hasOwnProperty(i)) {
			continue;
		}

		cascade_check = canCascade(i, npps);
		for (j = 0; j < cascade_check.length; j++) {
			already_cascading[cascade_check[j]] = true;
			npps = npps.concat(newNpp(cascade_check[j]));
		}
	}
	return npps;
}

function initBoard() {
	(function fill(p, allow_empty) {
		if (p >= START_HEIGHT * BOARD_WIDTH) {
			board[p] = 0;
		} else if (!allow_empty || Math.random() <= START_DENSITY) {
			board[p] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		} else {
			board[p] = 0;
		}

		if (p + 1 < (BOARD_HEIGHT * BOARD_WIDTH)) {
			if (
				match(left, p).length <= START_MAX_IN_A_ROW
				&& match(down, p).length <= START_MAX_IN_A_ROW
			) {
				fill(++p, true);
			} else {
				fill(p, false);
			}
		}
	}(0, true));
}

function gameOver() {
	console.log("GAME OVER!");
}

function isWin() {
	var p;
	for (p = 0; p < board.length; p++) {
		if (board[p] > 0 && board[p] <= NUM_COLORS) {
			return false;
		}
	}
	return true;
}

function win() {
	console.log("YOU WIN!");
}

// todo: figure out how to deal with rotation alternatives
function checkMove(direction) {
	var i,
		translated = Array.isArray(go[direction])
			? go[direction][this.orientation](this.blocks)
			: go[direction](this.blocks)
	;
	for (i = 0; i < translated.length; i++) {
		if (
			0 !== board[translated[i]]
			&& this.blocks.indexOf(translated[i]) === -1
		) {
			return false;
		}
	}
	return true;
}

function move(direction) {
	var i,
		copy = [],
		is_rotation = Array.isArray(go[direction])
	;
	for (i = 0; i < this.blocks.length; i++) {
		copy[i] = board[this.blocks[i]];
		board[this.blocks[i]] = 0;
	}
	this.blocks = is_rotation
		? go[direction][this.orientation](this.blocks)
		: go[direction](this.blocks)

	for (i = 0; i < copy.length; i++) {
		if (is_rotation) {
			copy[i] = rotation_state[this.orientation][i](copy[i]);
		}
		board[this.blocks[i]] = copy[i];
	}
	if (is_rotation) {
		this.orientation = (1 + this.orientation) % 4;
	}
}

function newPiece(now) {
	var i, blocks = [];
	for (i = 0; i < NEW_PIECE.length; i += 2) {
		if (board[NEW_PIECE[i]] !== 0) {
			// GAME OVER
			return;
		}
		board[NEW_PIECE[i]] = Math.floor(
			// a random color
			Math.random() * (NUM_COLORS)
			// set state for player piece
			+ NUM_COLORS + 1
			// set connection
			+ NEW_PIECE[i + 1]
		);
		blocks.push(NEW_PIECE[i]);
	}

	return {
		blocks: blocks,
		orientation: 0,
		pending_drop: now + DROP_INTERVAL,
		pending_settle: 0,
		pending_moves: [],
		move: move,
		checkMove: checkMove,
	};
}

function newNpp(p) {
	return {
		blocks: [p],
		pending_drop: 0,
		move: move,
		checkMove: checkMove
	};
}

function nppsSearch(p, npps) {
	var i, j;
	for (i = 0; i < npps.length; i++) {
		for (j = 0; j < npps[i].blocks.length; j++) {
			if (npps[i].blocks[j] === p) {
				return i;
			}
		}
	}
	return -1;
}

function removeConnectionComplement(p) {
	var target = go_connect[board[p] & CONNECTIONS](p);
	board[target] = board[target] & ~CONNECTIONS;
}

function playerLoop() {
	var now = new Date * 1,
		i, j,
		m,
		check_match = [],
		matches = [],
		npps = []
	;

	if (!piece) {
		piece = newPiece(now);
		if (!piece) {
			gameOver();
			return;
		}
	}

	if (piece.pending_settle) {
		if (piece.pending_settle <= now) {
			piece = false;

			matches = matchScan();

			if (matches.length > 0) {
				next(setMatches, [matches], SETTLE_INTERVAL);
				return;
			}
			next(playerLoop);
			return;
		}
	} else if (!piece.checkMove(down)) {
		piece.pending_settle = now + SETTLE_INTERVAL;
		piece.pending_drop = 0;
	} else if (piece.pending_drop && piece.pending_drop <= now) {
		piece.move(down);
		piece.pending_drop = now + DROP_INTERVAL;
	}

	m = piece.pending_moves.pop();
	if (m && piece.checkMove(m)) {
		piece.move(m);
		if (m === down && piece.checkMove(down)) {
			// Reset drop timer when piece is moved down
			piece.pending_drop = now + DROP_INTERVAL;
		} else {
			if (piece.pending_settle && piece.checkMove(down)) {
				// Unset the settle timer and re-set drop timer if the move has
				// resulted in more possible down moves.
				piece.pending_settle = 0;
				piece.pending_drop = now + DROP_INTERVAL;
			}
		}
	}

	next(playerLoop);
}

function nppSort(npp1, npp2) {
	return npp1.blocks[0] - npp2.blocks[0]; 
}

function cascadeLoop(npps) {
	var i,
		matches,
		new_npps
	;

	// Move the lowest npps first
	npps.sort(nppSort);

	for (i = 0; i < npps.length; i++) {
		npps[i].move(down);
	}

	new_npps = cascadeScan();

	if (new_npps.length < npps.length) {
		matches = matchScan();
		if (matches.length > 0) {
			next(setMatches, [matches], SETTLE_INTERVAL);
			return;
		}
	}

	next.apply(null, (new_npps.length > 0)
		? [cascadeLoop, [new_npps], DROP_INTERVAL_CASCADE]
		: [playerLoop]
	);
}

function setMatches(matches) {
	var i;
	for (i = 0; i < matches.length; i++) {
		if (board[matches[i]] & CONNECTIONS) {
			removeConnectionComplement(matches[i]);
		}

		board[matches[i]] = MATCH_PENDING;
	}
	next(clearMatches, [matches], MATCH_PAUSE);

}

function clearMatches(matches) {
	var i,
		npps = []
	;

	for (i = 0; i < matches.length; i++) {
		board[matches[i]] = 0;
	}

	if (isWin()) {
		return next(win);
	}

	npps = cascadeScan();
	next.apply(null, (npps.length > 0)
		? [cascadeLoop, [npps], DROP_INTERVAL_CASCADE]
		: [playerLoop]
	);
}

function next(fn, args, interval) {
	renderer.render(board);
	setTimeout(
		function () {
			fn.apply(null, args);
		},
		interval || DEFAULT_LOOP_DELAY
	);
}

renderer.init();

initBoard();
playerLoop();

onkeydown = function (e) {
	var d;
	switch (e.keyCode) {
		case 37: // left arrow
		case 65: // "a"
			piece && piece.pending_moves.unshift(left);
			return false;
		case 39: // right arrow
		case 68: // "d"
			piece && piece.pending_moves.unshift(right);
			return false;
		case 40: // down arrow
		case 83: // "s"
			piece && piece.pending_moves.unshift(down);
			return false;
		case 38: // up arrow
		case 87: // "w"
			// todo: instaplace
			return false;
		case 32: // space
		case 17: // ctrl
		case 13: // enter
		case 16: // shift
			piece && piece.pending_moves.unshift(rotate);
			return false;
		case 27: // ESC
			// debug -- STOP!!
			renderer.render(board);
			next = null;
			return false;
		default:
			return true;
	}
};
</script>
