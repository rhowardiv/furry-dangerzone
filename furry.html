<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
	}
	.c0 {
		background-color: black;
	}
	.c1 {
		background-color: #933;
	}
	.c2 {
		background-color: #993;
	}
	.c3 {
		background-color: #339;
	}
</style>
<div id="board"></div>
<script>
var BOARD_WIDTH = 8,
	BOARD_HEIGHT = 16,
	NUM_COLORS = 3,
	NUM_TO_MATCH = 4, // pieces in a row required for "match"
	DROP_INTERVAL = 900, // ms it takes an active piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing
	current_piece, // the piece currently being controlled by the player, if any
	look = {
		left: function (n) { return (n % BOARD_WIDTH) ? (n - 1) : -1; },
		right: function (n) { return (BOARD_WIDTH - (n % BOARD_WIDTH) - 1) ? (n + 1) : -1; },
		down: function (n) { return Math.floor(n / BOARD_WIDTH) ? (n - BOARD_WIDTH) : -1; },
		up: function (n) { return (BOARD_HEIGHT - Math.floor(n / BOARD_WIDTH) - 1) ? (n + BOARD_WIDTH) : -1; }
	},
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			console.log("block_size: " + block_size);

			board_dom.style.width = board_w + "px";
			console.log("board_w: " + board_dom.style.width);
			board_dom.style.height = board_h + "px";
			console.log("board_h: " + board_dom.style.height);

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.position = "absolute";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + board[i];
			}
		}

	}
;

function match(n, board, direction) {
	var l, m;

	if (board[n] === 0) {
		return [];
	}

	l = look[direction](n);
	if (
		l === -1
		|| (board[n] % NUM_COLORS) !== (board[l] % NUM_COLORS)
	) {
		return [n];
	}

	// l matches so keep looking that way
	m = match(l, board, direction);
	m.unshift(n);
	return m;
}

function newBoard() {
	var START_HEIGHT = 8, // max height to place starting yin pieces
		START_DENSITY = 0.8, // density of pieces on starting board, between 0 (nothing) and 1 (completely full)
		START_MAX_IN_A_ROW = 2; // don't allow more than this many pieces of the same color anywhere to start
	;

	// Create an empty board
	function empty() {
		var i, a = [];
		for (i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
			a.push(0);
		}
		return a;
	}

	// Populate spots on the board
	function fill(n, board, allow_empty) {
		board[n] = 0;
		if (allow_empty && Math.random() <= START_DENSITY) {
			board[n] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		}

		return (n == (START_HEIGHT * BOARD_WIDTH) - 1)
		? board
		: ((match(n, board, 'left').length <= START_MAX_IN_A_ROW && match(n, board, 'down').length <= START_MAX_IN_A_ROW)
			? fill(++n, board, true)
			: fill(n, board, false)
		);
	}

	return fill(0, empty(), true);
}

function loop(board) {
	renderer.render(board);
	setTimeout(function () {
		//loop(board);
	})
}

renderer.init();

loop(newBoard(BOARD_WIDTH, BOARD_HEIGHT));


</script>
