<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
		background: black;
	}
	div {
		-webkit-border-radius: 4px;
	}
/* empty block */
	.c0 {
		background-color: black;
	}
/* non-player block, inactive player block, active player block */
	.c1, .c4, .c7 {
		background-color: #933;
	}
	.c2, .c5, .c8 {
		background-color: #993;
	}
	.c3, .c6, .c9 {
		background-color: #339;
	}
</style>
<div id="board"></div>
<script>
var BOARD_WIDTH = 8,
	BOARD_HEIGHT = 17, // allow an extra top row for rotation
	NUM_COLORS = 3,
	NUM_TO_MATCH = 4, // pieces in a row required for "match"
	DROP_INTERVAL = 900, // ms it takes an active piece to move down one space
	DROP_INTERVAL_CASCADE = 500, // ms it takes a "cascading" piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing
	NEW_PIECE = [// new pieces start middle of second row from top
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2) - 1,
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2)
	],
	look = {
		left: function (n) { return (n % BOARD_WIDTH) ? (n - 1) : -1; },
		right: function (n) { return (BOARD_WIDTH - (n % BOARD_WIDTH) - 1) ? (n + 1) : -1; },
		down: function (n) { return Math.floor(n / BOARD_WIDTH) ? (n - BOARD_WIDTH) : -1; },
		up: function (n) { return (BOARD_HEIGHT - Math.floor(n / BOARD_WIDTH) - 1) ? (n + BOARD_WIDTH) : -1; }
	},
	direction_opposites = {
		left: "right",
		right: "left",
		down: "up",
		up: "down"
	},
	rotate_map = [ // this is how to rotate this piece in the possible orientations
		[
			function (n) { return n; },
			function (n) { return look.up(look.left(n)); }
		], [
			function (n) { return look.right(n); },
			function (n) { return look.down(n); }
		], [
			function (n) { return look.up(look.left(n)); },
			function (n) { return n; }
		], [
			function (n) { return look.down(n); },
			function (n) { return look.right(n); }
		]
	],
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			board_dom.style.width = board_w + "px";
			board_dom.style.height = board_h + "px";

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.position = "absolute";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					e.innerHTML = (i * BOARD_WIDTH) + j;
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + board[i];
			}
		}

	},
	// currently active piece
	piece,
	cascade_pieces = [],
	next_cascade = []
;

function match(n, board, direction) {
	var l, m;

	if (board[n] === 0) {
		return [];
	}

	l = look[direction](n);
	if (
		l === -1
		|| (board[n] % NUM_COLORS) !== (board[l] % NUM_COLORS)
	) {
		return [n];
	}

	// l matches so keep looking that way
	m = match(l, board, direction);
	m.unshift(n);
	return m;
}

function newBoard() {
	var START_HEIGHT = 8, // max height to place starting yin pieces
		START_DENSITY = 0.8, // density of pieces on starting board, between 0 (nothing) and 1 (completely full)
		START_MAX_IN_A_ROW = 2; // don't allow more than this many pieces of the same color anywhere to start
	;

	// Create an empty board
	function empty() {
		var i, a = [];
		for (i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
			a.push(0);
		}
		return a;
	}

	// Populate spots on the board
	function fill(n, board, allow_empty) {
		board[n] = 0;
		if (allow_empty && Math.random() <= START_DENSITY) {
			board[n] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		}

		return (n == (START_HEIGHT * BOARD_WIDTH) - 1)
		? board
		: ((match(n, board, 'left').length <= START_MAX_IN_A_ROW && match(n, board, 'down').length <= START_MAX_IN_A_ROW)
			? fill(++n, board, true)
			: fill(n, board, false)
		);
	}

	return fill(0, empty(), true);
}

function checkMove(direction) {
	var l;
	for (i = 0; i < this.blocks.length; i++) {
		l = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);

		if (
			0 !== this.board[l]
			&& this.blocks.indexOf(l) === -1
		) {
			return false;
		}
	}
	return true;
}

function move(direction) {
	var i, c;
	c = [];
	for (i = 0; i < this.blocks.length; i++) {
		c[i] = this.board[this.blocks[i]];
		this.board[this.blocks[i]] = 0;
		this.blocks[i] = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);
	}
	for (i = 0; i < c.length; i++) {
		this.board[this.blocks[i]] = c[i];
	}
	if (direction ==="rotate") {
		this.orientation = (1 + this.orientation) % 4;
	}
}

function newPiece(board, now) {
	var i, blocks = [];
	for (i = 0; i < NEW_PIECE.length; i++) {
		if (board[NEW_PIECE[i]] !== 0) {
			// GAME OVER
			return;
		}
		board[NEW_PIECE[i]] = Math.floor(Math.random() * (NUM_COLORS) + (NUM_COLORS * 2) + 1);
		blocks.push(NEW_PIECE[i]);
	}

	return {
		board: board,
		blocks: blocks,
		orientation: 0,
		pending_drop: now + DROP_INTERVAL,
		pending_settle: 0,
		pending_moves: [],
		move: move,
		checkMove: checkMove,
	};
}

function newCascadePiece(n, board) {
	return {
		board: board,
		blocks: [n],
		pending_drop: 0,
		move: move,
		checkMove: checkMove
	};
}

function loop(board) {
	var now = new Date * 1,
		i, j,
		bbl = [],
		m,
		check_match = [],
		matches = [],
		check_cascade
	;

	if (cascade_pieces.length > 0) {
		next_cascade = [];
		for (i = 0; i < cascade_pieces.length; i++) {
			if (cascade_pieces[i].pending_drop <= now) {
				cascade_pieces[i].move("down");
				if (cascade_pieces[i].checkMove("down")) {
					next_cascade.push(cascade_pieces[i]);
					cascade_pieces[i].pending_drop = now + DROP_INTERVAL_CASCADE;
				}
			} else {
				next_cascade.push(cascade_pieces[i]);
			}
		}
		cascade_pieces = next_cascade;
		return next(board);
	}

	if (!piece) {
		piece = newPiece(board, now);
		if (!piece) {
			// GAME OVER
			return;
		}
		board = piece.board;
	}

	if (piece.pending_settle) {
		if (piece.pending_settle <= now) {
			// convert piece blocks to inactive
			for (i = 0; i < piece.blocks.length; i++) {
				board[piece.blocks[i]] -= NUM_COLORS;
			}

			// check for matches!
			for (i = 0; i < piece.blocks.length; i++) {
				for (j in look) {
					if (look.hasOwnProperty(j)) {
						check_match = match(piece.blocks[i], board, j)
							// a match must include the opposite direction
							.concat(match(piece.blocks[i], board, direction_opposites[j]));
						// - 1 because the current block is included twice
						if (check_match.length - 1 >= NUM_TO_MATCH) {
							matches = matches.concat(check_match);
						}
					}
				}
				if (matches.length > 0) {
					for (j = 0; j < matches.length; j++) {
						board[matches[j]] = 0;
					}
				}
			}

			// deactivate the piece
			piece = false;

			// check for cascade pieces
			if (matches.length > 0) for (i = 0; i < board.length; i++) {
				// A piece that was placed by a player can cascade
				if (board[i] > NUM_COLORS && board[i] < (NUM_COLORS * 2) + 1) {
					check_cascade = newCascadePiece(i, board);
					if (check_cascade.checkMove("down") /* todo: OR if piece below is cascading */) {
						check_cascade.pending_drop = now + DROP_INTERVAL_CASCADE;
						cascade_pieces.push(check_cascade);
					}
				}
			}

			return next(board);
		}
	} else if (!piece.checkMove("down")) {
		piece.pending_settle = now + SETTLE_INTERVAL;
		piece.pending_drop = 0;
	} else if (piece.pending_drop && piece.pending_drop <= now) {
		piece.move('down');
		piece.pending_drop = now + DROP_INTERVAL;
	}

	m = piece.pending_moves.pop();
	if (m && piece.checkMove(m)) {
		piece.move(m);
		if (m === "down" && piece.checkMove("down")) {
			piece.pending_drop = now + DROP_INTERVAL;
		} else {
			if (piece.pending_settle && piece.checkMove("down")) {
				// Unset the settle timer and re-set drop timer if the move has
				// resulted in more possible down moves.
				piece.pending_settle = 0;
				piece.pending_drop = now + DROP_INTERVAL;
			}
		}
	}

	next(board);
}

function next(board) {
	renderer.render(board);
	setTimeout(function () {
		loop(board);
	}, 20)
}

renderer.init();

loop(newBoard(BOARD_WIDTH, BOARD_HEIGHT));

onkeydown = function (e) {
	var d;
	switch (e.keyCode) {
		case 37:
		case 65: "a"
			piece && piece.pending_moves.unshift("left");
			return false;
		case 39:
		case 68: "d"
			piece && piece.pending_moves.unshift("right");
			return false;
		case 40:
		case 83: "s"
			piece && piece.pending_moves.unshift("down");
			return false;
		case 38: // up arrow
		case 87: "w"
			// todo: instaplace
			return false;
		case 32: // space
		case 17: // ctrl
		case 13: // enter
		case 16: // shift
			piece && piece.pending_moves.unshift("rotate");
			return false;
		case 27: // ESC
			// debug -- STOP!!
			next = null;
			return false;
		default:
			return true;
	}
};
</script>
