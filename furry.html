<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
		background: black;
	}
	div {
		text-align: center;
	}
	.c0 {
		background-color: black;
	}
/* enemy blocks */
	.c1 {
		background-color: #933;
	}
	.c2 {
		background-color: #993;
	}
	.c3 {
		background-color: #339;
	}
/* unconnected blocks */
	.c4 {
		background-color: #c66;
		border-radius: 50%;
	}
	.c5 {
		background-color: #cc6;
		border-radius: 50%;
	}
	.c6 {
		background-color: #66c;
		border-radius: 50%;
	}
/* connected at top */
	.b1 {
		border-radius: 0;
		border-bottom-left-radius: 50%;
		border-bottom-right-radius: 50%;
	}
/* connected at right */
	.b2 {
		border-radius: 0;
		border-top-left-radius: 50%;
		border-bottom-left-radius: 50%;
	}
/* connected at bottom */
	.b4 {
		border-radius: 0;
		border-top-left-radius: 50%;
		border-top-right-radius: 50%;
	}
/* connected at left */
	.b8 {
		border-radius: 0;
		border-top-right-radius: 50%;
		border-bottom-right-radius: 50%;
	}

</style>
<div id="board"></div>
<script>
var
	// basic game parameters
	BOARD_WIDTH = 8,
	BOARD_HEIGHT = 17, // allow an extra top row for rotation
	NUM_COLORS = 3, // max 127! See comments on var board
	NUM_TO_MATCH = 4, // pieces in a row required for "match"
	DROP_INTERVAL = 800, // ms it takes an active piece to move down one space
	DROP_INTERVAL_CASCADE = 500, // ms it takes a "cascading" piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing

	// Game start parameters

	START_HEIGHT = 8,
	// Probabilistic density of pieces on starting board, between 0 (nothing)
	// and 1 (completely full)
	START_DENSITY = 0.8,
	// Max consecutive instances of any one color to start
	START_MAX_IN_A_ROW = 2,

	// bits that indicate connections
	CONNECT_TOP = 0x0100,
	CONNECT_RIGHT = 0x0200,
	CONNECT_BOTTOM = 0x0400,
	CONNECT_LEFT = 0x0800,
	CONNECTIONS = CONNECT_TOP | CONNECT_RIGHT | CONNECT_BOTTOM | CONNECT_LEFT,

	// New piece template
	NEW_PIECE = [
		// [ position, connect state[, ...] ]
		// (color will be added at generation)
		// These positions represent the middle of the second row from top.
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2) - 1, CONNECT_RIGHT,
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2), CONNECT_LEFT
	],
	// how to traverse the board
	go = {
		up: function (p) { return (BOARD_HEIGHT - Math.floor(p / BOARD_WIDTH) - 1) ? (p + BOARD_WIDTH) : -1; },
		right: function (p) { return (BOARD_WIDTH - (p % BOARD_WIDTH) - 1) ? (p + 1) : -1; },
		down: function (p) { return Math.floor(p / BOARD_WIDTH) ? (p - BOARD_WIDTH) : -1; },
		left: function (p) { return (p % BOARD_WIDTH) ? (p - 1) : -1; }
	},
	// sugar for object "literals" with expressions as keys
	makeHash = function(array) {
		var i, hash = {};
		for (i = 0; i < array.length; i += 2) {
			hash[array[i]] = array[i + 1];
		}
		return hash;
	},
	go_connect = makeHash([
		CONNECT_TOP, go.up,
		CONNECT_RIGHT, go.right,
		CONNECT_BOTTOM, go.down,
		CONNECT_LEFT, go.left
	]),
	opposite_connection = makeHash([
		CONNECT_TOP, CONNECT_BOTTOM,
		CONNECT_RIGHT, CONNECT_LEFT,
		CONNECT_BOTTOM, CONNECT_TOP,
		CONNECT_LEFT, CONNECT_RIGHT
	]),

	// How to rotate a player piece in all orientations.
	// function composition would be nice here
	rotation = [
		[
			function (p) { return p; },
			function (p) { return go.up(go.left(p)); }
		], [
			function (p) { return go.right(p); },
			function (p) { return go.down(p); }
		], [
			function (p) { return go.up(go.left(p)); },
			function (p) { return p; }
		], [
			function (p) { return go.down(p); },
			function (p) { return go.right(p); }
		]
	],
	// How to maintain state(connections) when rotating
	rotation_state = [
		[
			function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_TOP; },
			function (s) { return (s ^ CONNECT_LEFT) | CONNECT_BOTTOM; }
		], [
			function (s) { return (s ^ CONNECT_TOP) | CONNECT_LEFT; },
			function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_RIGHT; }
		], [
			function (s) { return (s ^ CONNECT_LEFT) | CONNECT_BOTTOM; },
			function (s) { return (s ^ CONNECT_RIGHT) | CONNECT_TOP; }
		], [
			function (s) { return (s ^ CONNECT_BOTTOM) | CONNECT_RIGHT; },
			function (s) { return (s ^ CONNECT_TOP) | CONNECT_LEFT; }
		]
	],
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			board_dom.style.width = board_w + "px";
			board_dom.style.height = board_h + "px";

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.position = "absolute";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					e.innerHTML = (i * BOARD_WIDTH) + j;
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + (board[i] % 256) + " b" + (board[i] >> 8);
			}
		}
	},

	// A list of integers representing the state of every spot on the board,
	// starting from the lower left. Possible states, where n = NUM_COLORS:
	// -1 invalid (not on board)
	//  0 empty
	//  1 - n "enemy" blocks placed at start
	//  n+1 - 2n unbound blocks
	//  ... Unbound block states can have the bits 2^8-11 flipped on to
	// indicate bindings to the top, right, bottom and left, respectively.
	board = [],

	// controllable piece, if one exists
	piece
;

function match(p, direction) {
	var g;

	if (board[p] === 0) {
		return [];
	}

	g = go[direction](p);
	if (
		g === -1
		|| (board[p] & ~CONNECTIONS) % NUM_COLORS !== (board[g] & ~CONNECTIONS) % NUM_COLORS
	) {
		return [p];
	}

	// g matches so keep looking that way
	return [p].concat(match(g, direction));
}

function matchScan() {
	var p,
		check_match,
		matches = []
	;
	for (p = 0; p < board.length; p++) {
		["up", "right"].forEach(function (dir) {
			check_match = match(p, dir);
			if (check_match.length >= NUM_TO_MATCH) {
				matches = matches.concat(check_match);
			}
		});
	}
	return matches;
}

function isPlayerBlock(p) {
	return board[p] > NUM_COLORS;
}

function canCascade(p, npps, from_conn) {
	if (board[p] <= NUM_COLORS) {
		// Only player blocks can cascade.
		return [];
	}

	from_conn = from_conn || 0;
	var below = go.down(p),
		conn_check,
		conn_cascades = []
		i
	;

	if (0 === (board[p] & (CONNECTIONS ^ from_conn))) {
		// I have no unexplored connections
		if (
			board[below] === 0
			|| nppsSearch(below, npps) > -1
		) {
			// The block below me is empty or is cascading
			if (nppsSearch(below, npps) > -1) {
				console.log("below " + p + " is cascading!");
				console.log(npps);
			}
			return [p];
		} else {
			return [];
		}
	}

	// The block below is not empty or cascading
	if (board[below] !== 0 && nppsSearch(below, npps) === -1) {
		return [];
	}

	console.log("checking connections from " + p + "(" + board[p] + ")...");

	// loop over all possible connections
	for (i = CONNECT_TOP; i & CONNECTIONS; i = i << 1) {
		if (i & from_conn || !(board[p] & i)) {
			// we came from this direction, or not connected
			continue;
		}
		console.log("looking at " + i);
		conn_check = canCascade(go_connect[i](p), npps, opposite_connection[i]);
		if (conn_check.length === 0) {
			// All connected blocks must be cascadable
			return [];
		} else {
			conn_cascades = conn_cascades.concat(conn_check);
		}
	}
	return conn_cascades.concat(p);
}

function cascadeScan() {
	var i, j,
		npps = [],
		cascade_check,
		already_cascading = {}
	;
	// We can skip the first row for obvious reasons
	for (i = BOARD_WIDTH; i < board.length; i++) {
		if (already_cascading.hasOwnProperty(i)) {
			continue;
		}

		cascade_check = canCascade(i, npps);
		for (j = 0; j < cascade_check.length; j++) {
			already_cascading[cascade_check[j]] = true;
			npps = npps.concat(newNpp(cascade_check[j]));
		}
	}
	return npps;
}

function initBoard() {
	(function fill(p, allow_empty) {
		if (p >= START_HEIGHT * BOARD_WIDTH) {
			board[p] = 0;
		} else if (!allow_empty || Math.random() <= START_DENSITY) {
			board[p] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		} else {
			board[p] = 0;
		}

		if (p + 1 < (BOARD_HEIGHT * BOARD_WIDTH)) {
			if (
				match(p, 'left').length <= START_MAX_IN_A_ROW
				&& match(p, 'down').length <= START_MAX_IN_A_ROW
			) {
				fill(++p, true);
			} else {
				fill(p, false);
			}
		}
	}(0, true));
}

function gameOver() {
	console.log("GAME OVER!");
}

// todo: special case here and in move() for rotation in right edge column
function checkMove(direction) {
	var g;
	for (i = 0; i < this.blocks.length; i++) {
		g = direction === "rotate"
			? rotation[this.orientation][i](this.blocks[i])
			: go[direction](this.blocks[i])
		;

		if (
			0 !== board[g]
			&& this.blocks.indexOf(g) === -1
		) {
			return false;
		}
	}
	return true;
}

function move(direction) {
	var i,
		copy = [],
		is_rotation = direction === "rotate"
	;
	for (i = 0; i < this.blocks.length; i++) {
		copy[i] = board[this.blocks[i]];
		board[this.blocks[i]] = 0;
		this.blocks[i] = is_rotation
			? rotation[this.orientation][i](this.blocks[i])
			: go[direction](this.blocks[i])
		;
	}
	for (i = 0; i < copy.length; i++) {
		if (is_rotation) {
			copy[i] = rotation_state[this.orientation][i](copy[i]);
		}
		board[this.blocks[i]] = copy[i];
	}
	if (is_rotation) {
		this.orientation = (1 + this.orientation) % 4;
	}
}

function newPiece(now) {
	var i, blocks = [];
	for (i = 0; i < NEW_PIECE.length; i += 2) {
		if (board[NEW_PIECE[i]] !== 0) {
			// GAME OVER
			return;
		}
		board[NEW_PIECE[i]] = Math.floor(Math.random() * (NUM_COLORS) + NUM_COLORS + 1 + NEW_PIECE[i + 1]);
		blocks.push(NEW_PIECE[i]);
	}

	return {
		blocks: blocks,
		orientation: 0,
		pending_drop: now + DROP_INTERVAL,
		pending_settle: 0,
		pending_moves: [],
		move: move,
		checkMove: checkMove,
	};
}

function newNpp(p) {
	return {
		blocks: [p],
		pending_drop: 0,
		move: move,
		checkMove: checkMove
	};
}

function nppSort(npp1, npp2) {
	return npp1.blocks[0] - npp2.blocks[0]; 
}

function nppsSearch(p, npps) {
	var i, j;
	for (i = 0; i < npps.length; i++) {
		for (j = 0; j < npps[i].blocks.length; j++) {
			if (npps[i].blocks[j] === p) {
				return i;
			}
		}
	}
	return -1;
}

function removeConnectionComplement(p) {
	var target = go_connect[board[p] & CONNECTIONS](p);
	board[target] = board[target] & ~CONNECTIONS;
}

function playerLoop() {
	var now = new Date * 1,
		i, j,
		m,
		check_match = [],
		matches = [],
		npps = []
	;

	if (!piece) {
		piece = newPiece(now);
		if (!piece) {
			gameOver();
			return;
		}
	}

	if (piece.pending_settle) {
		if (piece.pending_settle <= now) {
			piece = false;

			matches = matchScan();

			// todo: new state and loop for animating match removal
			if (matches.length > 0) {
				for (i = 0; i < matches.length; i++) {
					if (board[matches[i]] & CONNECTIONS) {
						removeConnectionComplement(matches[i]);
					}
					
					board[matches[i]] = 0;
				}
				npps = cascadeScan();
				if (npps.length > 0) {
					return next(cascadeLoop, [npps], DROP_INTERVAL_CASCADE);
				}
			}
			return next(playerLoop);
		}
	} else if (!piece.checkMove("down")) {
		piece.pending_settle = now + SETTLE_INTERVAL;
		piece.pending_drop = 0;
	} else if (piece.pending_drop && piece.pending_drop <= now) {
		piece.move('down');
		piece.pending_drop = now + DROP_INTERVAL;
	}

	m = piece.pending_moves.pop();
	if (m && piece.checkMove(m)) {
		piece.move(m);
		if (m === "down" && piece.checkMove("down")) {
			piece.pending_drop = now + DROP_INTERVAL;
		} else {
			if (piece.pending_settle && piece.checkMove("down")) {
				// Unset the settle timer and re-set drop timer if the move has
				// resulted in more possible down moves.
				piece.pending_settle = 0;
				piece.pending_drop = now + DROP_INTERVAL;
			}
		}
	}

	next(playerLoop);
}

function cascadeLoop(npps) {

	var now = new Date * 1,
		i,
		matches
	;

	// we must move the lowest npps first
	// debatable at this point
	//npps = nppsUnique(npps);
	npps.sort(nppSort);

	for (i = 0; i < npps.length; i++) {
		npps[i].move("down");
	}

	npps = cascadeScan();
	if (npps.length > 0) {
		return next(cascadeLoop, [npps], DROP_INTERVAL_CASCADE);
	}

	matches = matchScan();

	// todo: new state and loop for animating match removal
	if (matches.length > 0) {
		for (i = 0; i < matches.length; i++) {
			if (board[matches[i]] & CONNECTIONS) {
				removeConnectionComplement(matches[i]);
			}
			
			board[matches[i]] = 0;
		}
		npps = cascadeScan();
		if (npps.length > 0) {
			return next(cascadeLoop, [npps], DROP_INTERVAL_CASCADE);
		}
	}

	return next(playerLoop);
}

function next(fn, args, interval) {
	renderer.render(board);
	setTimeout(
		function () {
			fn.apply(null, args);
		},
		interval || 20
	);
}

renderer.init();

initBoard();
playerLoop();

onkeydown = function (e) {
	var d;
	switch (e.keyCode) {
		case 37: // left arrow
		case 65: // "a"
			piece && piece.pending_moves.unshift("left");
			return false;
		case 39: // right arrow
		case 68: // "d"
			piece && piece.pending_moves.unshift("right");
			return false;
		case 40: // down arrow
		case 83: // "s"
			piece && piece.pending_moves.unshift("down");
			return false;
		case 38: // up arrow
		case 87: // "w"
			// todo: instaplace
			return false;
		case 32: // space
		case 17: // ctrl
		case 13: // enter
		case 16: // shift
			piece && piece.pending_moves.unshift("rotate");
			return false;
		case 27: // ESC
			// debug -- STOP!!
			renderer.render(board);
			next = null;
			return false;
		default:
			return true;
	}
};
</script>
