<!DOCTYPE html>
<style>
	#board {
		position: relative;
		margin: 0 auto;
		background: black;
	}
	div {
		-webkit-border-radius: 4px;
	}
/* empty block */
	.c0 {
		background-color: black;
	}
/* non-player block, inactive player block, active player block */
	.c1, .c4, .c7 {
		background-color: #933;
	}
	.c2, .c5, .c8 {
		background-color: #993;
	}
	.c3, .c6, .c9 {
		background-color: #339;
	}
</style>
<div id="board"></div>
<script>
var BOARD_WIDTH = 8,
	BOARD_HEIGHT = 17, // allow an extra top row for rotation
	NUM_COLORS = 3,
	NUM_TO_MATCH = 4, // pieces in a row required for "match"
	DROP_INTERVAL = 900, // ms it takes an active piece to move down one space
	SETTLE_INTERVAL = 400, // ms it takes a piece to "settle" after landing
	NEW_PIECE = [// new pieces start middle of second row from top
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2) - 1,
		(BOARD_HEIGHT - 2) * BOARD_WIDTH + Math.floor(BOARD_WIDTH / 2)
	],
	look = {
		left: function (n) { return (n % BOARD_WIDTH) ? (n - 1) : -1; },
		right: function (n) { return (BOARD_WIDTH - (n % BOARD_WIDTH) - 1) ? (n + 1) : -1; },
		down: function (n) { return Math.floor(n / BOARD_WIDTH) ? (n - BOARD_WIDTH) : -1; },
		up: function (n) { return (BOARD_HEIGHT - Math.floor(n / BOARD_WIDTH) - 1) ? (n + BOARD_WIDTH) : -1; }
	},
	rotate_map = [ // this is how to rotate this piece in the possible orientations
		[
			function (n) { return n; },
			function (n) { return look.up(look.left(n)); }
		], [
			function (n) { return look.right(n); },
			function (n) { return look.down(n); }
		], [
			function (n) { return look.up(look.left(n)); },
			function (n) { return n; }
		], [
			function (n) { return look.down(n); },
			function (n) { return look.right(n); }
		]
	],
	renderer = {
		board_dom: null,
		init: function () {
			this.board_dom = this.setupBoardDom(BOARD_WIDTH, BOARD_HEIGHT);

		},
		setupBoardDom: function (w, h) {
			var board_dom = document.getElementById("board"),
				screen_w = window.document.documentElement.clientWidth,
				screen_h = window.document.documentElement.clientHeight,
				block_size = Math.floor(Math.min(screen_w, screen_h) / Math.max(w, h)),
				board_w = block_size * w,
				board_h = block_size * h,
				i, j, e
			;

			console.log("block_size: " + block_size);

			board_dom.style.width = board_w + "px";
			console.log("board_w: " + board_dom.style.width);
			board_dom.style.height = board_h + "px";
			console.log("board_h: " + board_dom.style.height);

			for (i = 0; i < h; i++) {
				for (j = 0; j < w; j++) {
					e = document.createElement("div");
					e.className = "c0";
					e.style.position = "absolute";
					e.style.bottom = i * block_size + "px";
					e.style.left = j * block_size + "px";
					e.style.width = block_size + "px";
					e.style.height = block_size + "px";
					board_dom.appendChild(e);
				}
			}

			return board_dom;
		},

		render: function (board) {
			var i, c = this.board_dom.childNodes;
			for (i = 0; i < board.length; i++) {
				c[i].className = "c" + board[i];
			}
		}

	},
	// currently active piece
	piece
;

function match(n, board, direction) {
	var l, m;

	if (board[n] === 0) {
		return [];
	}

	l = look[direction](n);
	if (
		l === -1
		|| (board[n] % NUM_COLORS) !== (board[l] % NUM_COLORS)
	) {
		return [n];
	}

	// l matches so keep looking that way
	m = match(l, board, direction);
	m.unshift(n);
	return m;
}

function newBoard() {
	var START_HEIGHT = 8, // max height to place starting yin pieces
		START_DENSITY = 0.8, // density of pieces on starting board, between 0 (nothing) and 1 (completely full)
		START_MAX_IN_A_ROW = 2; // don't allow more than this many pieces of the same color anywhere to start
	;

	// Create an empty board
	function empty() {
		var i, a = [];
		for (i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
			a.push(0);
		}
		return a;
	}

	// Populate spots on the board
	function fill(n, board, allow_empty) {
		board[n] = 0;
		if (allow_empty && Math.random() <= START_DENSITY) {
			board[n] = Math.floor(Math.random() * (NUM_COLORS) + 1);
		}

		return (n == (START_HEIGHT * BOARD_WIDTH) - 1)
		? board
		: ((match(n, board, 'left').length <= START_MAX_IN_A_ROW && match(n, board, 'down').length <= START_MAX_IN_A_ROW)
			? fill(++n, board, true)
			: fill(n, board, false)
		);
	}

	return fill(0, empty(), true);
}

function checkMove(direction) {
	var l;
	for (i = 0; i < this.blocks.length; i++) {
		l = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);

		if (
			0 !== this.board[l]
			&& this.blocks.indexOf(l) === -1
		) {
			direction != "down" && console.log(direction + " denied");
			return false;
		}
	}
	direction != "down" && console.log(direction + " allowed");
	return true;
}

function move(direction) {
	var i, c;
	c = [];
	for (i = 0; i < this.blocks.length; i++) {
		c[i] = this.board[this.blocks[i]];
		this.board[this.blocks[i]] = 0;
		this.blocks[i] = direction === "rotate"
		? rotate_map[this.orientation][i](this.blocks[i])
		: look[direction](this.blocks[i]);
	}
	for (i = 0; i < c.length; i++) {
		this.board[this.blocks[i]] = c[i];
	}
	if (direction ==="rotate") {
		this.orientation = (1 + this.orientation) % 4;
	}
}

function newPiece(board, now) {
	var i, blocks = [];
	for (i = 0; i < NEW_PIECE.length; i++) {
		if (board[NEW_PIECE[i]] !== 0) {
			// GAME OVER
			return;
		}
		board[NEW_PIECE[i]] = Math.floor(Math.random() * (NUM_COLORS) + (NUM_COLORS * 2) + 1);
		blocks.push(NEW_PIECE[i]);
	}

	return {
		board: board,
		blocks: blocks,
		orientation: 0,
		pending_drop: now + DROP_INTERVAL,
		pending_settle: 0,
		pending_moves: [],
		move: move,
		checkMove: checkMove,
	};
}

function loop(board) {
	var now = new Date * 1,
		i,
		bbl = [],
		m
	;

	if (!piece) {
		piece = newPiece(board, now);
		if (!piece) {
			// GAME OVER
			return;
		}
		board = piece.board;
	}

	if (piece.pending_settle) {
		if (piece.pending_settle <= now) {
			for (i = 0; i < piece.blocks.length; i++) {
				// convert block to inactive
				board[piece.blocks[i]] -= NUM_COLORS;
				// todo: check for matches!
			}
			piece = false;
			return next(board);
		}
	} else if (!piece.checkMove("down")) {
		piece.pending_settle = now;
		piece.pending_drop = 0;
	} else if (piece.pending_drop && piece.pending_drop <= now) {
		piece.move('down');
		piece.pending_drop = now + DROP_INTERVAL;
	}

	m = piece.pending_moves.pop();
	if (m && piece.checkMove(m)) {
		piece.move(m);
	}

	next(board);
}

function next(board) {
	renderer.render(board);
	setTimeout(function () {
		loop(board);
	}, 10)
}

renderer.init();

loop(newBoard(BOARD_WIDTH, BOARD_HEIGHT));

onkeydown = function (e) {
	var d;
	switch (e.keyCode) {
		case 37:
			console.log("queuing left ");
			piece.pending_moves.unshift("left");
			break;
		case 39:
			console.log("queuing right ");
			piece.pending_moves.unshift("right");
			break;
		case 40:
			// todo: move down
			break;
		default:
			console.log("queuing rotate ");
			piece.pending_moves.unshift("rotate");
			break;
	}
	return false;
};
</script>
